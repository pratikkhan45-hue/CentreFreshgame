<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Center Fresh: Fresh Dash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0a;
      color: #f5f7ff;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #gameCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .hud {
      position: absolute;
      z-index: 10;
      display: flex;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.55);
      border-radius: 999px;
      backdrop-filter: blur(6px);
      align-items: center;
      font-size: 13px;
      line-height: 1.2;
      white-space: nowrap;
    }

    #scoreDisplay { top: 8px; left: 8px; }
    #levelDisplay { top: 8px; right: 8px; }
    #timerDisplay { top: 8px; left: 50%; transform: translateX(-50%); }
    #livesDisplay { bottom: 8px; left: 8px; }

    #loveBarWrapper {
      position: absolute;
      top: 44px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      pointer-events: none;
    }

    #loveBarCanvas {
      display: block;
    }

    #storyOverlay,
    #startOverlay,
    #gameOverOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      text-align: center;
      padding: 20px;
      color: #f9fafb;
    }

    #storyOverlay {
      z-index: 30;
      background: rgba(0,0,0,0.95);
    }

    #startOverlay {
      background: none;
      backdrop-filter: blur(8px);
    }

    #startOverlay::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image: url('./images/supermarket.jpg');
      background-size: cover;
      background-position: center;
      filter: brightness(0.3) blur(2px);
      z-index: -1;
    }

    #gameOverOverlay {
      background: rgba(0,0,0,0.95);
    }

    #storyImage {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #storyControls {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .story-nav {
      background: rgba(0,0,0,0.7);
      color: #f9fafb;
      border: 1px solid rgba(148, 163, 184, 0.7);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .story-nav:hover:not(:disabled) {
      background: rgba(15, 23, 42, 0.9);
      transform: scale(1.1);
    }

    .story-nav:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    #storyProgress {
      padding: 6px 14px;
      background: rgba(0,0,0,0.7);
      border-radius: 999px;
      font-size: 13px;
      margin: 0 10px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: clamp(26px, 4vw, 34px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    h1 span {
      display: block;
      font-size: 0.6em;
      opacity: 0.8;
      letter-spacing: 0.15em;
    }

    p.subtitle {
      margin: 0 0 14px;
      font-size: 14px;
      opacity: 0.9;
      max-width: 480px;
    }

    .brand-line {
      margin-bottom: 14px;
      font-size: 13px;
      max-width: 520px;
    }

    .brand-line strong { color: #a8fff1; }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 9px 20px;
      margin: 6px 0;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00e6c0, #00b4ff);
      color: #031019;
      box-shadow: 0 10px 25px rgba(0, 180, 255, 0.4);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 30px rgba(0, 180, 255, 0.6);
    }

    .btn-ghost {
      background: transparent;
      color: #e2e8ff;
      border: 1px solid rgba(148, 163, 184, 0.7);
    }

    .btn-ghost:hover {
      background: rgba(15, 23, 42, 0.8);
    }

    .hint {
      margin-top: 10px;
      font-size: 11px;
      opacity: 0.7;
      max-width: 520px;
    }

    #resultImage {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #gameOverOverlay {
      padding: 0;
      flex-direction: column;
    }

    #gameOverControls {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="loveBarWrapper">
      <canvas id="loveBarCanvas"></canvas>
    </div>

    <div id="scoreDisplay" class="hud">
      <span>Freshness:&nbsp;<strong id="scoreValue">0</strong></span>
    </div>

    <div id="levelDisplay" class="hud">
      <span>Level:&nbsp;<strong id="levelValue">1</strong></span>
    </div>

    <div id="timerDisplay" class="hud">
      <span>Time:&nbsp;<strong id="timerValue">60</strong>s</span>
    </div>

    <div id="livesDisplay" class="hud">
      <span>Roses:&nbsp;<span id="livesValue"></span></span>
    </div>

    <!-- Story Overlay -->
    <div id="storyOverlay">
      <img id="storyImage" src="" alt="Story panel" />
      <div id="storyControls">
        <button class="story-nav" id="prevStoryBtn">‚Üê</button>
        <span id="storyProgress">1 / 4</span>
        <button class="story-nav" id="nextStoryBtn">‚Üí</button>
      </div>
    </div>

    <div id="startOverlay" style="display:none;">
      <h1>
        CENTER FRESH
        <span>FRESH DASH</span>
      </h1>
      <p class="subtitle">
        Sonu has 60 seconds to fix his bad breath and win Sona's heart.
        Dodge garlic & onions, grab Center Fresh & Center Fruit, and fill the Love bar at the top.
      </p>
      <p class="brand-line">
        <strong>Level 1 (0‚Äì20s):</strong> Easy ‚Äì slower smells, fewer obstacles.<br/>
        <strong>Level 2 (20‚Äì40s):</strong> Medium ‚Äì more onions & garlic, faster fall speed.<br/>
        <strong>Level 3 (40‚Äì60s):</strong> Hard ‚Äì chaos mode.<br/><br/>
        Survive all 60 seconds <strong>and</strong> fill the Love bar green to the girl's side to unlock the
        happy ending. Lose all 3 roses early and you'll see different story panels for Level 1 or Level 2.
      </p>
      <button class="btn btn-primary" id="startButton">Tap to Play</button>
      <button class="btn btn-ghost" id="howToButton">How to Play</button>
      <div class="hint">
        Controls: ‚Üê / ‚Üí or A / D keys ¬∑ On touch: tap left / right side of the screen.<br/>
        Collect <strong>Center Fresh</strong> & <strong>Center Fruit</strong> ‚Üí Freshness score ‚Üë & Love bar ‚Üë & Sonu looks happy.<br/>
        Hit <strong>garlic/onion</strong> ‚Üí lose a rose, Love bar ‚Üì & Sonu becomes sad for a moment.
      </div>
    </div>

    <div id="gameOverOverlay" style="display:none;">
      <img id="resultImage" src="" alt="Result panel" />
      <div id="gameOverControls">
        <button class="btn btn-primary" id="restartButton">Play Again</button>
        <button class="btn btn-ghost" id="backToStartButton">Back to Start</button>
      </div>
    </div>
  </div>

  <script>
    // ======== Canvas Setup (NO DPR scaling for smoothness) ========
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const loveBarCanvas = document.getElementById("loveBarCanvas");
    const loveCtx = loveBarCanvas.getContext("2d");
    const LOVE_BAR_WIDTH = 400;
    const LOVE_BAR_HEIGHT = 100;

    function resizeCanvases() {
      // Simple resize without DPR - much faster!
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      loveBarCanvas.width = LOVE_BAR_WIDTH;
      loveBarCanvas.height = LOVE_BAR_HEIGHT;

      // Reposition player after resize
      playerY = canvas.height * 0.75 - playerHeight / 2;
      playerX = canvas.width / 2 - playerWidth / 2;
    }

    // ======== Game State ========
    let gameRunning = false;
    let gameOver = false;
    let globalTime = 0;

    let freshnessScore = 0;
    let currentLevel = 1;

    const maxLives = 3;
    let lives = maxLives;

    const playerWidth = 90;
    const playerHeight = 90;
    let playerX = 0;
    let playerY = 0;
    let playerSpeed = 10;

    let gameSpeed = 3.5;
    const collectibles = [];
    const obstacles = [];
    const objectSize = 70;

    let loveProgress = 0.25;
    const TOTAL_TIME = 60;
    let elapsedTime = 0;
    let lastFrameTime = null;

    let boyMood = "normal";
    let moodTimeoutId = null;

    let collectibleSpawnId = null;
    let obstacleSpawnId = null;

    const scoreValueEl = document.getElementById("scoreValue");
    const levelValueEl = document.getElementById("levelValue");
    const timerValueEl = document.getElementById("timerValue");
    const livesValueEl = document.getElementById("livesValue");

    const startOverlay = document.getElementById("startOverlay");
    const gameOverOverlay = document.getElementById("gameOverOverlay");
    const storyOverlay = document.getElementById("storyOverlay");
    const storyImage = document.getElementById("storyImage");
    const storyProgress = document.getElementById("storyProgress");
    const prevStoryBtn = document.getElementById("prevStoryBtn");
    const nextStoryBtn = document.getElementById("nextStoryBtn");
    const startButton = document.getElementById("startButton");
    const howToButton = document.getElementById("howToButton");
    const restartButton = document.getElementById("restartButton");
    const backToStartButton = document.getElementById("backToStartButton");
    const resultImageEl = document.getElementById("resultImage");

    // ======== Story Slides ========
    const storySlides = [
      "./images/story_slide0.jpg",  // NEW: Title/intro slide
      "./images/story_slide1.jpg",
      "./images/story_slide2.jpg",
      "./images/story_slide3.jpg",
      "./images/story_slide4.jpg"
    ];
    let currentSlide = 0;

    // ======== Game Music ========
    const bgMusic = new Audio("./audio/2-17. Fortree City.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.6; // 60% volume (increased from 50%)

    function playMusic() {
      console.log("Attempting to play music...");
      bgMusic.play()
        .then(() => {
          console.log("‚úÖ Music playing successfully!");
        })
        .catch(err => {
          console.error("‚ùå Music autoplay blocked or error:", err);
          // Try again on next user interaction
          document.addEventListener('click', () => {
            bgMusic.play().catch(e => console.log("Still blocked:", e));
          }, { once: true });
        });
    }

    function stopMusic() {
      console.log("Stopping music...");
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }

    function showStorySlide(index) {
      currentSlide = index;
      storyImage.src = storySlides[index];
      storyProgress.textContent = `${index + 1} / ${storySlides.length}`;
      
      prevStoryBtn.disabled = index === 0;
      
      if (index === storySlides.length - 1) {
        nextStoryBtn.textContent = "START";
        nextStoryBtn.style.width = "auto";
        nextStoryBtn.style.borderRadius = "999px";
        nextStoryBtn.style.padding = "0 20px";
      } else {
        nextStoryBtn.textContent = "‚Üí";
        nextStoryBtn.style.width = "50px";
        nextStoryBtn.style.borderRadius = "50%";
        nextStoryBtn.style.padding = "0";
      }
    }

    prevStoryBtn.addEventListener("click", () => {
      if (currentSlide > 0) {
        showStorySlide(currentSlide - 1);
      }
    });

    nextStoryBtn.addEventListener("click", () => {
      // Try to play music on first interaction
      if (currentSlide === 0) {
        playMusic();
      }
      
      if (currentSlide < storySlides.length - 1) {
        showStorySlide(currentSlide + 1);
      } else {
        // Last slide - start game
        storyOverlay.style.display = "none";
        startOverlay.style.display = "flex";
        playMusic(); // Ensure music is playing
      }
    });

    // ======== Assets ========
    function loadImage(src) {
      const img = new Image();
      img.src = src;
      return img;
    }

    const bgImg = loadImage("./images/supermarket.jpg");
    const centerFreshImg = loadImage("./images/centerfresh.png");
    const centerFruitImg = loadImage("./images/centerfruit.png");

    const garlicImages = [ loadImage("./images/garlic.png") ];
    const onionImages = [
      loadImage("./images/onion1.png"),
      loadImage("./images/onion2.png")
    ];

    const boyNormalImg = loadImage("./images/runnerBoy_normal.png");
    const boyHappyImg = loadImage("./images/runnerBoy_happy.png");
    const boySadImg = loadImage("./images/runnerBoy_sad.png");

    const loveBoyImg = loadImage("./images/love_boy.png");
    const loveGirlImg = loadImage("./images/love_girl.png");

    const resultFailLvl1Img = loadImage("./images/outcome_fail_level1.png");
    const resultFailLvl2Img = loadImage("./images/outcome_fail_level2.png");
    const resultSuccessImg = loadImage("./images/outcome_success.png");

    // ======== Utils ========
    function randBetween(min, max) {
      return Math.random() * (max - min) + min;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function setBoyMood(mood, durationMs = 500) {
      boyMood = mood;
      if (moodTimeoutId) clearTimeout(moodTimeoutId);
      if (mood !== "normal") {
        moodTimeoutId = setTimeout(() => {
          boyMood = "normal";
        }, durationMs);
      }
    }

    function getBoySprite() {
      if (boyMood === "happy") return boyHappyImg;
      if (boyMood === "sad") return boySadImg;
      return boyNormalImg;
    }

    // ======== Game Init / Reset ========
    function initGameState() {
      freshnessScore = 0;
      currentLevel = 1;
      lives = maxLives;
      gameSpeed = 3.5;
      playerSpeed = 10;
      collectibles.length = 0;
      obstacles.length = 0;
      loveProgress = 0.25;
      elapsedTime = 0;
      lastFrameTime = null;
      boyMood = "normal";
      globalTime = 0;

      playerX = canvas.width / 2 - playerWidth / 2;
      playerY = canvas.height * 0.75 - playerHeight / 2;

      clearInterval(collectibleSpawnId);
      clearInterval(obstacleSpawnId);
      updateDifficultyForLevel(1);
      updateHUD();
    }

    function updateDifficultyForLevel(lvl) {
      clearInterval(collectibleSpawnId);
      clearInterval(obstacleSpawnId);

      if (lvl === 1) {
        // Easy: Slow speed, more time between obstacles
        gameSpeed = 3;
        collectibleSpawnId = setInterval(spawnCollectible, 900);
        obstacleSpawnId = setInterval(spawnObstacle, 1400);
      } else if (lvl === 2) {
        // Medium: Moderate speed, balanced spawns
        gameSpeed = 4.5;
        collectibleSpawnId = setInterval(spawnCollectible, 700);
        obstacleSpawnId = setInterval(spawnObstacle, 1000);
      } else {
        // Hard: Fast speed, frequent obstacles (but still fair)
        gameSpeed = 6;
        collectibleSpawnId = setInterval(spawnCollectible, 550);
        obstacleSpawnId = setInterval(spawnObstacle, 800);
      }
    }

    function startGame() {
      gameOver = false;
      gameRunning = true;
      startOverlay.style.display = "none";
      gameOverOverlay.style.display = "none";

      initGameState();
      requestAnimationFrame(gameLoop);
    }

    function endGame(outcome) {
      gameRunning = false;
      gameOver = true;
      clearInterval(collectibleSpawnId);
      clearInterval(obstacleSpawnId);
      stopMusic(); // Stop music when game ends

      if (outcome === "success") {
        resultImageEl.src = resultSuccessImg.src;
      } else if (outcome === "fail_lvl1") {
        resultImageEl.src = resultFailLvl1Img.src;
      } else {
        resultImageEl.src = resultFailLvl2Img.src;
      }

      gameOverOverlay.style.display = "flex";
    }

    // ======== Spawning ========
    function spawnCollectible() {
      if (!gameRunning) return;
      const brand = Math.random() < 0.6 ? "centerFresh" : "centerFruit";
      const x = randBetween(20, canvas.width - 20 - objectSize);

      collectibles.push({
        x,
        y: -objectSize,
        size: objectSize,
        brand
      });
    }

    function spawnObstacle() {
      if (!gameRunning) return;
      const kind = Math.random() < 0.5 ? "garlic" : "onion";
      const x = randBetween(20, canvas.width - 20 - objectSize);
      const imgIndex =
        kind === "garlic"
          ? Math.floor(Math.random() * garlicImages.length)
          : Math.floor(Math.random() * onionImages.length);

      obstacles.push({
        x,
        y: -objectSize,
        size: objectSize,
        kind,
        imgIndex
      });
    }

    // ======== Drawing ========
    function drawBackground() {
      if (bgImg.complete && bgImg.naturalWidth) {
        const imgW = bgImg.naturalWidth;
        const imgH = bgImg.naturalHeight;
        const scale = Math.max(canvas.width / imgW, canvas.height / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const dx = (canvas.width - drawW) / 2;
        const dy = (canvas.height - drawH) / 2;
        ctx.drawImage(bgImg, dx, dy, drawW, drawH);
      } else {
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function drawCollectible(c) {
      const img = c.brand === "centerFresh" ? centerFreshImg : centerFruitImg;
      const w = objectSize;
      const h = objectSize * 0.7;
      if (img.complete) {
        ctx.drawImage(img, c.x, c.y, w, h);
      }
    }

    function drawObstacle(o) {
      let img;
      if (o.kind === "garlic") {
        img = garlicImages[o.imgIndex % garlicImages.length];
      } else {
        img = onionImages[o.imgIndex % onionImages.length];
      }
      if (img.complete) {
        ctx.drawImage(img, o.x, o.y, o.size, o.size);
      }
    }

    function drawPlayer() {
      const img = getBoySprite();
      if (img.complete) {
        ctx.drawImage(img, playerX, playerY, playerWidth, playerHeight);
      } else {
        ctx.fillStyle = "#0ea5e9";
        ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
      }
    }

    function drawLoveBar() {
      loveCtx.clearRect(0, 0, LOVE_BAR_WIDTH, LOVE_BAR_HEIGHT);

      const pad = 12;
      const iconSize = 64;
      const barWidth = LOVE_BAR_WIDTH - pad * 2 - iconSize * 2 - 24;
      const barHeight = 24;
      const barX = pad + iconSize + 12;
      const barY = (LOVE_BAR_HEIGHT - barHeight) / 2;

      if (loveBoyImg.complete) {
        loveCtx.drawImage(
          loveBoyImg,
          pad,
          (LOVE_BAR_HEIGHT - iconSize) / 2,
          iconSize,
          iconSize
        );
      }

      if (loveGirlImg.complete) {
        loveCtx.drawImage(
          loveGirlImg,
          LOVE_BAR_WIDTH - pad - iconSize,
          (LOVE_BAR_HEIGHT - iconSize) / 2,
          iconSize,
          iconSize
        );
      }

      loveCtx.fillStyle = "#1f2933";
      loveCtx.beginPath();
      loveCtx.roundRect(barX, barY, barWidth, barHeight, 12);
      loveCtx.fill();

      const filledWidth = barWidth * clamp(loveProgress, 0, 1);
      const grad = loveCtx.createLinearGradient(barX, barY, barX + filledWidth, barY);
      grad.addColorStop(0, "#ef4444");
      grad.addColorStop(1, "#22c55e");
      loveCtx.fillStyle = grad;
      loveCtx.beginPath();
      loveCtx.roundRect(barX, barY, filledWidth, barHeight, 12);
      loveCtx.fill();

      loveCtx.strokeStyle = "#e5e7eb";
      loveCtx.lineWidth = 2;
      loveCtx.beginPath();
      loveCtx.roundRect(barX, barY, barWidth, barHeight, 12);
      loveCtx.stroke();
    }

    // ======== HUD ========
    function updateHUD() {
      scoreValueEl.textContent = Math.round(freshnessScore).toString();
      levelValueEl.textContent = currentLevel.toString();
      const remaining = Math.max(0, Math.ceil(TOTAL_TIME - elapsedTime));
      timerValueEl.textContent = remaining.toString();

      let roses = "";
      for (let i = 0; i < lives; i++) roses += "üåπ";
      livesValueEl.textContent = roses || "‚Äî";
    }

    // ======== Game Loop (Optimized) ========
    function gameLoop(timestamp) {
      if (!gameRunning) return;
      
      if (lastFrameTime == null) lastFrameTime = timestamp;
      const dt = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;
      globalTime = timestamp / 1000;

      elapsedTime += dt;
      if (elapsedTime >= TOTAL_TIME) {
        if (lives > 0 && loveProgress >= 0.9) {
          endGame("success");
        } else {
          endGame("fail_lvl2");
        }
        return;
      }

      const newLevel =
        elapsedTime < 20 ? 1 :
        elapsedTime < 40 ? 2 : 3;
      if (newLevel !== currentLevel) {
        currentLevel = newLevel;
        updateDifficultyForLevel(currentLevel);
      }

      // Clear and draw background once
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();

      // Update and draw collectibles
      for (let i = collectibles.length - 1; i >= 0; i--) {
        const c = collectibles[i];
        c.y += gameSpeed;

        const playerRect = { x: playerX, y: playerY, w: playerWidth, h: playerHeight };
        const cRect = { x: c.x, y: c.y, w: objectSize, h: objectSize * 0.7 };

        if (rectsOverlap(playerRect, cRect)) {
          const scoreAdd = c.brand === "centerFresh" ? 10 : 12;
          freshnessScore += scoreAdd;
          loveProgress = clamp(loveProgress + 0.03, 0, 1);
          setBoyMood("happy", 450);
          collectibles.splice(i, 1);
          continue;
        }

        if (c.y > canvas.height + 80) {
          collectibles.splice(i, 1);
          continue;
        }

        drawCollectible(c);
      }

      // Update and draw obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.y += gameSpeed + 0.8;

        const playerRect = { x: playerX, y: playerY, w: playerWidth, h: playerHeight };
        const oRect = { x: o.x, y: o.y, w: o.size, h: o.size };

        if (rectsOverlap(playerRect, oRect)) {
          lives--;
          loveProgress = clamp(loveProgress - 0.09, 0, 1);
          setBoyMood("sad", 600);
          obstacles.splice(i, 1);
          if (lives <= 0) {
            if (elapsedTime < 20) {
              endGame("fail_lvl1");
            } else {
              endGame("fail_lvl2");
            }
            return;
          }
          continue;
        }

        if (o.y > canvas.height + 80) {
          obstacles.splice(i, 1);
          continue;
        }

        drawObstacle(o);
      }

      drawPlayer();
      drawLoveBar();
      updateHUD();

      requestAnimationFrame(gameLoop);
    }

    // ======== Controls ========
    const keys = { left: false, right: false };

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = true;
      if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = true;
    });

    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keys.left = false;
      if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") keys.right = false;
    });

    function updatePlayerPosition() {
      if (gameRunning) {
        if (keys.left) playerX -= playerSpeed;
        if (keys.right) playerX += playerSpeed;
        if (playerX < 0) playerX = 0;
        if (playerX + playerWidth > canvas.width) playerX = canvas.width - playerWidth;
      }
      requestAnimationFrame(updatePlayerPosition);
    }

    canvas.addEventListener("touchstart", (e) => {
      if (!gameRunning || gameOver) return;
      const t = e.touches[0];
      if (!t) return;
      const mid = canvas.width / 2;
      if (t.clientX < mid) {
        keys.left = true;
        keys.right = false;
      } else {
        keys.right = true;
        keys.left = false;
      }
    });

    canvas.addEventListener("touchend", () => {
      keys.left = false;
      keys.right = false;
    });

    // ======== Buttons ========
    startButton.addEventListener("click", startGame);

    howToButton.addEventListener("click", () => {
      alert(
        "üéÆ HOW TO PLAY:\n\n" +
        "üìñ THE STORY:\n" +
        "Sonu wants to propose to Sona, but he has bad breath! He has exactly 60 seconds to collect fresh mints and fruits while avoiding stinky garlic and onions. Fill the Love Bar completely and survive to win her heart!\n\n" +
        "‚è±Ô∏è 3 LEVELS IN 60 SECONDS:\n" +
        "‚Ä¢ Level 1 (0-20 seconds): EASY - Slow falling items, fewer obstacles\n" +
        "‚Ä¢ Level 2 (20-40 seconds): MEDIUM - Faster items, more obstacles\n" +
        "‚Ä¢ Level 3 (40-60 seconds): HARD - Very fast, many obstacles!\n\n" +
        "üéØ CONTROLS:\n" +
        "‚Ä¢ Desktop: Use ‚Üê ‚Üí arrow keys OR A/D keys\n" +
        "‚Ä¢ Mobile: Tap left/right side of screen\n\n" +
        "‚ú® COLLECT (GOOD):\n" +
        "‚Ä¢ Center Fresh (blue) - Adds freshness points\n" +
        "‚Ä¢ Center Fruit (pink) - Adds more freshness points\n" +
        "‚Ä¢ Both fill the Love Bar and make Sonu happy!\n\n" +
        "üíî AVOID (BAD):\n" +
        "‚Ä¢ Garlic & Onions - Lose 1 rose (life)\n" +
        "‚Ä¢ Reduces the Love Bar\n" +
        "‚Ä¢ Makes Sonu sad temporarily\n\n" +
        "üèÜ WIN CONDITIONS:\n" +
        "‚Ä¢ Survive all 60 seconds\n" +
        "‚Ä¢ Fill the Love Bar to green (reach the girl's side)\n" +
        "‚Ä¢ Keep at least 1 rose remaining\n" +
        "= Sona says YES! üíö\n\n" +
        "üíÄ LOSE CONDITIONS:\n" +
        "‚Ä¢ Lose all 3 roses = Different sad endings based on which level you reached\n" +
        "‚Ä¢ Time runs out with low Love Bar = Proposal rejected\n\n" +
        "Good luck, Sonu! üåπ"
      );
    });

    restartButton.addEventListener("click", startGame);

    backToStartButton.addEventListener("click", () => {
      gameOverOverlay.style.display = "none";
      stopMusic(); // Stop music when going back
      currentSlide = 0;
      showStorySlide(0);
      storyOverlay.style.display = "flex";
    });

    // ======== Init ========
    window.addEventListener("resize", resizeCanvases);
    resizeCanvases();
    initGameState();
    updatePlayerPosition();
    showStorySlide(0); // Start with first story slide
  </script>
</body>
</html>
